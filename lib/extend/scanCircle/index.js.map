{"version":3,"file":"index.js","sources":["src/components/extend/scanCircle/VcScanCircle.vue?rollup-plugin-vue=script.js","src/components/extend/scanCircle/VcScanCircle.vue","src/components/extend/scanCircle/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport cmp from '../../../mixins/virtualCmp'\nimport { position, color } from '../../../mixins/mixinProps'\nexport default {\n  name: 'vc-scan-circle',\n  mixins: [cmp, position, color],\n  props: {\n    radius: {\n      type: Number,\n      default: 1500\n    },\n    interval: {\n      type: Number,\n      default: 3000\n    }\n  },\n  watch: {\n    position () {\n      this.reload()\n    },\n    color () {\n      this.reload()\n    },\n    radius () {\n      this.reload()\n    },\n    interval () {\n      this.reload()\n    }\n  },\n  methods: {\n    async createCesiumObject () {\n      const { $props, transformProps, viewer } = this\n      const options = transformProps($props)\n      const cartographicCenter = Cesium.Cartographic.fromCartesian(options.position, viewer.scene.globe.ellipsoid)\n      const _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1)\n      const _CartographicCenter1 = new Cesium.Cartographic(\n        cartographicCenter.longitude,\n        cartographicCenter.latitude,\n        cartographicCenter.height + 500\n      )\n      const _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1)\n      const _time = new Date().getTime()\n      const _scratchCartesian4Center = new Cesium.Cartesian4()\n      const _scratchCartesian4Center1 = new Cesium.Cartesian4()\n      const _scratchCartesian3Normal = new Cesium.Cartesian3()\n      this.uniforms = {\n        u_scanCenterEC: function () {\n          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n        },\n        u_scanPlaneNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          return _scratchCartesian3Normal\n        },\n        u_radius: function () {\n          return (options.radius * ((new Date().getTime() - _time) % options.interval)) / options.interval\n        },\n        u_scanColor: options.color\n      }\n      return this.$refs.stage\n    },\n    async mount () {\n      return true\n    },\n    async unmount () {\n      return true\n    }\n  },\n  created () {\n    Object.defineProperties(this, {\n      postProcessStage: {\n        enumerable: true,\n        get: () => this.cesiumObject\n      }\n    })\n  },\n  data () {\n    return {\n      fsScanSegment: `\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          if(dis < u_radius)\n          {\n            float f = 1.0 -abs(u_radius - dis) / u_radius;\n            f = pow(f, 4.0);\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f);\n          }\n        }`,\n      uniforms: {}\n    }\n  }\n}\n","<template>\n  <i :class=\"$options.name\" style=\"display: none !important\">\n    <vc-stage-process-post :fragmentShader=\"fsScanSegment\" :uniforms=\"uniforms\" ref=\"stage\"></vc-stage-process-post>\n  </i>\n</template>\n\n<script>\nimport cmp from '../../../mixins/virtualCmp'\nimport { position, color } from '../../../mixins/mixinProps'\nexport default {\n  name: 'vc-scan-circle',\n  mixins: [cmp, position, color],\n  props: {\n    radius: {\n      type: Number,\n      default: 1500\n    },\n    interval: {\n      type: Number,\n      default: 3000\n    }\n  },\n  watch: {\n    position () {\n      this.reload()\n    },\n    color () {\n      this.reload()\n    },\n    radius () {\n      this.reload()\n    },\n    interval () {\n      this.reload()\n    }\n  },\n  methods: {\n    async createCesiumObject () {\n      const { $props, transformProps, viewer } = this\n      const options = transformProps($props)\n      const cartographicCenter = Cesium.Cartographic.fromCartesian(options.position, viewer.scene.globe.ellipsoid)\n      const _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1)\n      const _CartographicCenter1 = new Cesium.Cartographic(\n        cartographicCenter.longitude,\n        cartographicCenter.latitude,\n        cartographicCenter.height + 500\n      )\n      const _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1)\n      const _time = new Date().getTime()\n      const _scratchCartesian4Center = new Cesium.Cartesian4()\n      const _scratchCartesian4Center1 = new Cesium.Cartesian4()\n      const _scratchCartesian3Normal = new Cesium.Cartesian3()\n      this.uniforms = {\n        u_scanCenterEC: function () {\n          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n        },\n        u_scanPlaneNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          return _scratchCartesian3Normal\n        },\n        u_radius: function () {\n          return (options.radius * ((new Date().getTime() - _time) % options.interval)) / options.interval\n        },\n        u_scanColor: options.color\n      }\n      return this.$refs.stage\n    },\n    async mount () {\n      return true\n    },\n    async unmount () {\n      return true\n    }\n  },\n  created () {\n    Object.defineProperties(this, {\n      postProcessStage: {\n        enumerable: true,\n        get: () => this.cesiumObject\n      }\n    })\n  },\n  data () {\n    return {\n      fsScanSegment: `\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          if(dis < u_radius)\n          {\n            float f = 1.0 -abs(u_radius - dis) / u_radius;\n            f = pow(f, 4.0);\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f);\n          }\n        }`,\n      uniforms: {}\n    }\n  }\n}\n</script>\n","import VcScanCircle from './VcScanCircle.vue'\nimport * as PostProcessStage from '../../stage'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n  Vue.use(PostProcessStage)\n  Vue.component(VcScanCircle.name, VcScanCircle)\n}\n\nexport default plugin\n\nexport {\n  VcScanCircle,\n  plugin as install\n}\n"],"names":["name","mixins","cmp","position","color","props","radius","type","Number","default","interval","watch","reload","methods","createCesiumObject","$props","transformProps","viewer","options","cartographicCenter","Cesium","Cartographic","fromCartesian","scene","globe","ellipsoid","_Cartesian3Center","toCartesian","_Cartesian4Center","Cartesian4","x","y","z","_CartographicCenter1","longitude","latitude","height","_Cartesian3Center1","_Cartesian4Center1","_time","Date","getTime","_scratchCartesian4Center","_scratchCartesian4Center1","_scratchCartesian3Normal","Cartesian3","uniforms","u_scanCenterEC","Matrix4","multiplyByVector","camera","_viewMatrix","u_scanPlaneNormalEC","temp","temp1","normalize","u_radius","u_scanColor","$refs","stage","mount","unmount","created","Object","defineProperties","postProcessStage","enumerable","get","cesiumObject","data","fsScanSegment","plugin","Vue","installed","use","PostProcessStage","component","VcScanCircle"],"mappings":"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"}