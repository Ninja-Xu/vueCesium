{"version":3,"file":"index.js","sources":["src/components/extend/scanRadar/VcScanRadar.vue?rollup-plugin-vue=script.js","src/components/extend/scanRadar/VcScanRadar.vue","src/components/extend/scanRadar/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n\nimport cmp from '../../../mixins/virtualCmp'\nimport { position, color } from '../../../mixins/mixinProps'\nexport default {\n  name: 'vc-scan-radar',\n  mixins: [cmp, position, color],\n  props: {\n    radius: {\n      type: Number,\n      default: 1500\n    },\n    interval: {\n      type: Number,\n      default: 3000\n    }\n  },\n  watch: {\n    position () {\n      this.reload()\n    },\n    color () {\n      this.reload()\n    },\n    radius () {\n      this.reload()\n    },\n    interval () {\n      this.reload()\n    }\n  },\n  methods: {\n    async createCesiumObject () {\n      const { $props, transformProps, viewer } = this\n      const options = transformProps($props)\n      const cartographicCenter = Cesium.Cartographic.fromCartesian(options.position, viewer.scene.globe.ellipsoid)\n      const _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1)\n      const _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500)\n      const _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1)\n      const _CartographicCenter2 = new Cesium.Cartographic(cartographicCenter.longitude + Cesium.Math.toRadians(0.001), cartographicCenter.latitude, cartographicCenter.height)\n      const _Cartesian3Center2 = Cesium.Cartographic.toCartesian(_CartographicCenter2, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center2 = new Cesium.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1)\n      const _RotateQ = new Cesium.Quaternion()\n      const _RotateM = new Cesium.Matrix3()\n      const _time = (new Date()).getTime()\n      const _scratchCartesian4Center = new Cesium.Cartesian4()\n      const _scratchCartesian4Center1 = new Cesium.Cartesian4()\n      const _scratchCartesian4Center2 = new Cesium.Cartesian4()\n      const _scratchCartesian3Normal = new Cesium.Cartesian3()\n      const _scratchCartesian3Normal1 = new Cesium.Cartesian3()\n      this.uniforms = {\n        u_scanCenterEC: function () {\n          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n        },\n        u_scanPlaneNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          return _scratchCartesian3Normal\n        },\n        u_radius: options.radius,\n        u_scanLineNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          const temp2 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          _scratchCartesian3Normal1.x = temp2.x - temp.x\n          _scratchCartesian3Normal1.y = temp2.y - temp.y\n          _scratchCartesian3Normal1.z = temp2.z - temp.z\n          const tempTime = (((new Date()).getTime() - _time) % options.interval) / options.interval\n          Cesium.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * Cesium.Math.PI * 2, _RotateQ)\n          Cesium.Matrix3.fromQuaternion(_RotateQ, _RotateM)\n          Cesium.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1)\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1)\n          return _scratchCartesian3Normal1\n        },\n        u_scanColor: options.color\n      }\n      return this.$refs.stage\n    },\n    async mount () {\n      return true\n    },\n    async unmount () {\n      return true\n    }\n  },\n  created () {\n    Object.defineProperties(this, {\n      postProcessStage: {\n        enumerable: true,\n        get: () => this.cesiumObject\n      }\n    })\n  },\n  data () {\n    return {\n      fsScanSegment: `\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform vec3 u_scanLineNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 v01 = testPt - ptOnLine;\n          normalize(v01);\n          vec3 temp = cross(v01, lineNormal);\n          float d = dot(temp, u_scanPlaneNormalEC);\n          return d > 0.5;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\n          return length(tempPt - ptOnLine);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          float twou_radius = u_radius * 2.0;\n          if(dis < u_radius)\n          {\n            float f0 = 1.0 -abs(u_radius - dis) / u_radius;\n            f0 = pow(f0, 64.0);\n            vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\n            float f = 0.0;\n            if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))\n            {\n              float dis1= length(prjOnPlane.xyz - lineEndPt);\n              f = abs(twou_radius -dis1) / twou_radius;\n              f = pow(f, 3.0);\n            }\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\n          }\n        }`,\n      uniforms: {}\n    }\n  }\n}\n","<template>\n  <i :class=\"$options.name\" style=\"display: none !important\">\n    <vc-stage-process-post :fragmentShader=\"fsScanSegment\" :uniforms=\"uniforms\" ref=\"stage\"></vc-stage-process-post>\n  </i>\n</template>\n\n<script>\nimport cmp from '../../../mixins/virtualCmp'\nimport { position, color } from '../../../mixins/mixinProps'\nexport default {\n  name: 'vc-scan-radar',\n  mixins: [cmp, position, color],\n  props: {\n    radius: {\n      type: Number,\n      default: 1500\n    },\n    interval: {\n      type: Number,\n      default: 3000\n    }\n  },\n  watch: {\n    position () {\n      this.reload()\n    },\n    color () {\n      this.reload()\n    },\n    radius () {\n      this.reload()\n    },\n    interval () {\n      this.reload()\n    }\n  },\n  methods: {\n    async createCesiumObject () {\n      const { $props, transformProps, viewer } = this\n      const options = transformProps($props)\n      const cartographicCenter = Cesium.Cartographic.fromCartesian(options.position, viewer.scene.globe.ellipsoid)\n      const _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1)\n      const _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500)\n      const _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1)\n      const _CartographicCenter2 = new Cesium.Cartographic(cartographicCenter.longitude + Cesium.Math.toRadians(0.001), cartographicCenter.latitude, cartographicCenter.height)\n      const _Cartesian3Center2 = Cesium.Cartographic.toCartesian(_CartographicCenter2, viewer.scene.globe.ellipsoid)\n      const _Cartesian4Center2 = new Cesium.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1)\n      const _RotateQ = new Cesium.Quaternion()\n      const _RotateM = new Cesium.Matrix3()\n      const _time = (new Date()).getTime()\n      const _scratchCartesian4Center = new Cesium.Cartesian4()\n      const _scratchCartesian4Center1 = new Cesium.Cartesian4()\n      const _scratchCartesian4Center2 = new Cesium.Cartesian4()\n      const _scratchCartesian3Normal = new Cesium.Cartesian3()\n      const _scratchCartesian3Normal1 = new Cesium.Cartesian3()\n      this.uniforms = {\n        u_scanCenterEC: function () {\n          return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n        },\n        u_scanPlaneNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          return _scratchCartesian3Normal\n        },\n        u_radius: options.radius,\n        u_scanLineNormalEC: function () {\n          const temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center)\n          const temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1)\n          const temp2 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2)\n          _scratchCartesian3Normal.x = temp1.x - temp.x\n          _scratchCartesian3Normal.y = temp1.y - temp.y\n          _scratchCartesian3Normal.z = temp1.z - temp.z\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal)\n          _scratchCartesian3Normal1.x = temp2.x - temp.x\n          _scratchCartesian3Normal1.y = temp2.y - temp.y\n          _scratchCartesian3Normal1.z = temp2.z - temp.z\n          const tempTime = (((new Date()).getTime() - _time) % options.interval) / options.interval\n          Cesium.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * Cesium.Math.PI * 2, _RotateQ)\n          Cesium.Matrix3.fromQuaternion(_RotateQ, _RotateM)\n          Cesium.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1)\n          Cesium.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1)\n          return _scratchCartesian3Normal1\n        },\n        u_scanColor: options.color\n      }\n      return this.$refs.stage\n    },\n    async mount () {\n      return true\n    },\n    async unmount () {\n      return true\n    }\n  },\n  created () {\n    Object.defineProperties(this, {\n      postProcessStage: {\n        enumerable: true,\n        get: () => this.cesiumObject\n      }\n    })\n  },\n  data () {\n    return {\n      fsScanSegment: `\n        uniform sampler2D colorTexture;\n        uniform sampler2D depthTexture;\n        varying vec2 v_textureCoordinates;\n        uniform vec4 u_scanCenterEC;\n        uniform vec3 u_scanPlaneNormalEC;\n        uniform vec3 u_scanLineNormalEC;\n        uniform float u_radius;\n        uniform vec4 u_scanColor;\n        vec4 toEye(in vec2 uv, in float depth)\n        {\n          vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n          vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n          posInCamera =posInCamera / posInCamera.w;\n          return posInCamera;\n        }\n        bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 v01 = testPt - ptOnLine;\n          normalize(v01);\n          vec3 temp = cross(v01, lineNormal);\n          float d = dot(temp, u_scanPlaneNormalEC);\n          return d > 0.5;\n        }\n        vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n        {\n          vec3 v01 = point -planeOrigin;\n          float d = dot(planeNormal, v01) ;\n          return (point - planeNormal * d);\n        }\n        float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n        {\n          vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\n          return length(tempPt - ptOnLine);\n        }\n        float getDepth(in vec4 depth)\n        {\n          float z_window = czm_unpackDepth(depth);\n          z_window = czm_reverseLogDepth(z_window);\n          float n_range = czm_depthRange.near;\n          float f_range = czm_depthRange.far;\n          return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n        }\n        void main()\n        {\n          gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\n          float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\n          vec4 viewPos = toEye(v_textureCoordinates, depth);\n          vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\n          float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\n          float twou_radius = u_radius * 2.0;\n          if(dis < u_radius)\n          {\n            float f0 = 1.0 -abs(u_radius - dis) / u_radius;\n            f0 = pow(f0, 64.0);\n            vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\n            float f = 0.0;\n            if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))\n            {\n              float dis1= length(prjOnPlane.xyz - lineEndPt);\n              f = abs(twou_radius -dis1) / twou_radius;\n              f = pow(f, 3.0);\n            }\n            gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\n          }\n        }`,\n      uniforms: {}\n    }\n  }\n}\n</script>\n","import VcScanRadar from './VcScanRadar.vue'\nimport * as PostProcessStage from '../../stage'\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n  Vue.use(PostProcessStage)\n  Vue.component(VcScanRadar.name, VcScanRadar)\n}\n\nexport default plugin\n\nexport {\n  VcScanRadar,\n  plugin as install\n}\n"],"names":["name","mixins","cmp","position","color","props","radius","type","Number","default","interval","watch","reload","methods","createCesiumObject","$props","transformProps","viewer","options","cartographicCenter","Cesium","Cartographic","fromCartesian","scene","globe","ellipsoid","_Cartesian3Center","toCartesian","_Cartesian4Center","Cartesian4","x","y","z","_CartographicCenter1","longitude","latitude","height","_Cartesian3Center1","_Cartesian4Center1","_CartographicCenter2","Math","toRadians","_Cartesian3Center2","_Cartesian4Center2","_RotateQ","Quaternion","_RotateM","Matrix3","_time","Date","getTime","_scratchCartesian4Center","_scratchCartesian4Center1","_scratchCartesian4Center2","_scratchCartesian3Normal","Cartesian3","_scratchCartesian3Normal1","uniforms","u_scanCenterEC","Matrix4","multiplyByVector","camera","_viewMatrix","u_scanPlaneNormalEC","temp","temp1","normalize","u_radius","u_scanLineNormalEC","temp2","tempTime","fromAxisAngle","PI","fromQuaternion","u_scanColor","$refs","stage","mount","unmount","created","Object","defineProperties","postProcessStage","enumerable","get","cesiumObject","data","fsScanSegment","plugin","Vue","installed","use","PostProcessStage","component","VcScanRadar"],"mappings":"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"}