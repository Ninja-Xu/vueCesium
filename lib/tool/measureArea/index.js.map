{"version":3,"file":"index.js","sources":["src/components/tool/measureArea/VcMeasureArea.vue?rollup-plugin-vue=script.js","src/components/tool/measureArea/VcMeasureArea.vue","src/components/tool/measureArea/index.js"],"sourcesContent":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport area from '@turf/area'\nimport mixinMeasure from '../../../mixins/tool/mixinMeasure'\nimport { makeMaterial } from '../../../utils/cesiumHelpers'\nimport { clone } from '../../../utils/util'\nexport default {\n  name: 'vc-measure-area',\n  mixins: [mixinMeasure],\n  data () {\n    return {\n      index: 0,\n      type: 'areaMeasuring',\n      measuring: false,\n      polylines: []\n    }\n  },\n  props: {\n    removeLastPosition: {\n      type: Boolean,\n      default: true\n    },\n    clampToGround: {\n      type: Boolean,\n      default: false\n    },\n    alongLine: {\n      type: Boolean,\n      default: true\n    },\n    polygonMaterial: {\n      type: Object,\n      default: () => {\n        return {\n          fabric: {\n            type: 'Color',\n            uniforms: {\n              color: 'rgba(255,165,0,0.25)'\n            }\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    clampToGround () {\n      const { getSurfaceArea, getDistance, polylines } = this\n      polylines.forEach((polyline) => {\n        polyline.area = getSurfaceArea(polyline.positions)\n\n        const distances = [0]\n        let totalDistance = 0\n        for (let i = 0; i < polyline.positions.length; i++) {\n          const positions = [polyline.positions[i], polyline.positions.length - 1 !== i\n            ? polyline.positions[i + 1]\n            : polyline.positions[0]]\n          const distance = getDistance(positions)\n          totalDistance += distance\n          distances.push(totalDistance)\n        }\n        polyline.distances = distances\n        polyline.distance = totalDistance\n      })\n    }\n  },\n  computed: {\n    primitivePolylines () {\n      const polylines = []\n      this.polylines.forEach((item, index) => {\n        const polyline = {\n          material: this.polylineMaterial,\n          positions: item.positions,\n          width: this.polylineWidth,\n          polylineIndex: index,\n          loop: true\n        }\n        polylines.push(polyline)\n      })\n      return polylines\n    },\n    labels () {\n      const labels = []\n      this.polylines.forEach((polyline, index) => {\n        const label = {\n          backgroundColor: this.backgroundColor,\n          fillColor: this.fillColor,\n          font: this.font,\n          horizontalOrigin: 1,\n          labelStyle: this.labelStyle,\n          outlineColor: this.outlineColor,\n          outlineWidth: this.outlineWidth,\n          pixelOffset: this.pixelOffset,\n          position: polyline.positions[polyline.positions.length - 1],\n          showBackground: this.showBackground,\n          disableDepthTestDistance: Cesium.SuperMapVersion ? 0 : Number.POSITIVE_INFINITY,\n          text: this.$vc.lang.measure.area +\n              ': ' +\n              (polyline.area > 1000000 ? (polyline.area / 1000000).toFixed(2) + 'km²' : polyline.area.toFixed(2) + '㎡')\n        }\n        labels.push(label)\n        polyline.positions.forEach((position, subIndex) => {\n          if (this.alongLine && polyline.positions.length > 1 && subIndex + 1 < polyline.distances.length) {\n            const label = {\n              backgroundColor: this.backgroundColor,\n              fillColor: this.fillColor,\n              font: this.font,\n              horizontalOrigin: 0,\n              labelStyle: this.labelStyle,\n              outlineColor: this.outlineColor,\n              outlineWidth: this.outlineWidth,\n              pixelOffset: this.pixelOffset,\n              position: subIndex !== polyline.positions.length - 1\n                ? this.getMidPoistion(polyline.positions[subIndex], polyline.positions[subIndex + 1])\n                : this.getMidPoistion(polyline.positions[subIndex], polyline.positions[0]),\n              showBackground: this.showBackground,\n              disableDepthTestDistance: Number.POSITIVE_INFINITY,\n              text: this.getDistanceText(polyline.distances[subIndex + 1] - polyline.distances[subIndex]),\n              verticalOrigin: 0\n            }\n            labels.push(label)\n          }\n        })\n      })\n      return labels\n    }\n  },\n  methods: {\n    getDistanceText (distance) {\n      return distance > 1000 ? (distance / 1000).toFixed(2) + 'km' : distance.toFixed(2) + 'm'\n    },\n    getMidPoistion (left, right) {\n      const { Cartesian3 } = Cesium\n      return Cartesian3.midpoint(left, right, new Cartesian3())\n    },\n    makeEllipsoidSurfaceAppearance (val) {\n      return new Cesium.EllipsoidSurfaceAppearance({\n        material: makeMaterial.call(this, val),\n        renderState: {\n          cull: {\n            enabled: false\n          }\n        }\n      })\n    },\n    makePolylineMaterialAppearance (val) {\n      return new Cesium.PolylineMaterialAppearance({\n        material: makeMaterial.call(this, val)\n      })\n    },\n    clone,\n    /**\n     * 用海伦公式获取传入坐标的构成的多边形的面积。\n     * @param {Array.Cartesian}\n     * @returns {Number} 返回面积数值。\n     */\n    getSurfaceArea (vals) {\n      const positions = clone(vals, true)\n      if (positions.length < 3) {\n        return 0\n      }\n      const {\n        Cartesian3,\n        EllipsoidTangentPlane,\n        Math: CesiumMath,\n        PolygonGeometryLibrary,\n        PolygonHierarchy,\n        VertexFormat,\n        ArcType\n      } = Cesium\n      const { viewer } = this\n      const perPositionHeight = !this.clampToGround\n      // Request the triangles that make up the polygon from Cesium.\n      // 获取组成多边形的三角形。\n      const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, viewer.scene.globe.ellipsoid)\n      const polygons = PolygonGeometryLibrary.polygonsFromHierarchy(\n        new PolygonHierarchy(positions),\n        tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\n        this.clampToGround,\n        viewer.scene.globe.ellipsoid\n      )\n\n      const geom = PolygonGeometryLibrary.createGeometryFromPositions(\n        viewer.scene.globe.ellipsoid,\n        polygons.polygons[0],\n        CesiumMath.RADIANS_PER_DEGREE,\n        perPositionHeight,\n        VertexFormat.POSITION_ONLY,\n        ArcType.GEODESIC\n      )\n\n      if (geom.indices.length % 3 !== 0 || geom.attributes.position.values.length % 3 !== 0) {\n        // Something has gone wrong. We expect triangles. Can't calcuate area.\n        // 不是三角形，无法计算。\n        return 0\n      }\n      const coords = []\n      for (let i = 0; i < geom.attributes.position.values.length; i += 3) {\n        coords.push(\n          new Cartesian3(\n            geom.attributes.position.values[i],\n            geom.attributes.position.values[i + 1],\n            geom.attributes.position.values[i + 2]\n          )\n        )\n      }\n      let area = 0\n      for (let i = 0; i < geom.indices.length; i += 3) {\n        const ind1 = geom.indices[i]\n        const ind2 = geom.indices[i + 1]\n        const ind3 = geom.indices[i + 2]\n\n        const a = Cartesian3.distance(coords[ind1], coords[ind2])\n        const b = Cartesian3.distance(coords[ind2], coords[ind3])\n        const c = Cartesian3.distance(coords[ind3], coords[ind1])\n\n        // Heron's formula 海伦公式\n        const s = (a + b + c) / 2.0\n        area += Math.sqrt(s * (s - a) * (s - b) * (s - c))\n      }\n      return area\n    },\n    /**\n     * 用 @turf/area 获取传入坐标的构成的多边形的面积。实际上是投影面积。\n     * @param {Array.Cartesian}\n     * @returns {Number} 返回面积数值。\n     */\n    getProjectedArea (positions) {\n      const { Cartographic, Math: CesiumMath } = Cesium\n      const array = []\n      for (let i = 0, len = positions.length; i < len; i++) {\n        const cartographic = Cartographic.fromCartesian(positions[i], this.viewer.scene.globe.ellipsoid)\n        const longitude = CesiumMath.toDegrees(cartographic.longitude).toFixed(6)\n        const latitude = CesiumMath.toDegrees(cartographic.latitude).toFixed(6)\n        array.push({ x: longitude, y: latitude })\n      }\n      const arrs = []\n      const tems = []\n      arrs.push(tems)\n      for (let i = 0, len = array.length; i < len; i++) {\n        tems.push([array[i].x, array[i].y])\n      }\n      const polygons = {\n        type: 'FeatureCollection',\n        features: [\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: arrs\n            }\n          },\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: [[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]]\n            }\n          }\n        ]\n      }\n      return area(polygons)\n    },\n    clear () {\n      this.distance = 0\n      this.polylines = []\n      // this.labels = []\n      this.measuring = false\n    }\n  }\n}\n","<template>\n  <i :class=\"$options.name\" style=\"display: none !important\">\n    <!-- 贴地面 -->\n    <vc-collection-primitive ref=\"groundPolygonCollection\" v-if=\"clampToGround\">\n      <template v-for=\"(polyline, index) of polylines\">\n        <vc-primitive-ground\n          :appearance=\"makeEllipsoidSurfaceAppearance(polygonMaterial)\"\n          :asynchronous=\"false\"\n          :key=\"index\"\n          v-if=\"polyline.positions.length > 2\"\n        >\n          <vc-instance-geometry>\n            <vc-geometry-polygon :perPositionHeight=\"false\" :polygonHierarchy=\"clone(polyline.positions, true)\"></vc-geometry-polygon>\n          </vc-instance-geometry>\n        </vc-primitive-ground>\n      </template>\n    </vc-collection-primitive>\n    <!-- 非贴地面 -->\n    <vc-collection-primitive ref=\"polygonCollection\" v-else>\n      <template v-for=\"(polyline, index) of polylines\">\n        <vc-primitive\n          :appearance=\"makeEllipsoidSurfaceAppearance(polygonMaterial)\"\n          :asynchronous=\"false\"\n          :key=\"index\"\n          v-if=\"polyline.positions.length > 2\"\n        >\n          <vc-instance-geometry>\n            <vc-geometry-polygon :perPositionHeight=\"true\" :polygonHierarchy=\"clone(polyline.positions, true)\"></vc-geometry-polygon>\n          </vc-instance-geometry>\n        </vc-primitive>\n      </template>\n    </vc-collection-primitive>\n    <!-- 贴地线 -->\n    <vc-collection-primitive ref=\"groundPolylineCollection\" v-if=\"clampToGround\">\n      <template v-for=\"(polyline, index) of polylines\">\n        <vc-primitive-polyline-ground\n          :appearance=\"makePolylineMaterialAppearance(polylineMaterial)\"\n          :asynchronous=\"false\"\n          :key=\"index\"\n          v-if=\"polyline.positions.length > 1\"\n        >\n          <vc-instance-geometry>\n            <vc-geometry-polyline-ground :positions=\"polyline.positions\" :width=\"polylineWidth\" loop></vc-geometry-polyline-ground>\n          </vc-instance-geometry>\n        </vc-primitive-polyline-ground>\n      </template>\n    </vc-collection-primitive>\n    <!-- 非贴地线 -->\n    <vc-collection-primitive-polyline ref=\"polylineCollection\" :polylines=\"primitivePolylines\" v-else></vc-collection-primitive-polyline>\n    <vc-collection-primitive-point ref=\"pointCollection\" :points=\"points\"></vc-collection-primitive-point>\n    <vc-collection-primitive-label ref=\"labelCollection\" :labels=\"labels\"></vc-collection-primitive-label>\n  </i>\n</template>\n\n<script>\nimport area from '@turf/area'\nimport mixinMeasure from '../../../mixins/tool/mixinMeasure'\nimport { makeMaterial } from '../../../utils/cesiumHelpers'\nimport { clone } from '../../../utils/util'\nexport default {\n  name: 'vc-measure-area',\n  mixins: [mixinMeasure],\n  data () {\n    return {\n      index: 0,\n      type: 'areaMeasuring',\n      measuring: false,\n      polylines: []\n    }\n  },\n  props: {\n    removeLastPosition: {\n      type: Boolean,\n      default: true\n    },\n    clampToGround: {\n      type: Boolean,\n      default: false\n    },\n    alongLine: {\n      type: Boolean,\n      default: true\n    },\n    polygonMaterial: {\n      type: Object,\n      default: () => {\n        return {\n          fabric: {\n            type: 'Color',\n            uniforms: {\n              color: 'rgba(255,165,0,0.25)'\n            }\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    clampToGround () {\n      const { getSurfaceArea, getDistance, polylines } = this\n      polylines.forEach((polyline) => {\n        polyline.area = getSurfaceArea(polyline.positions)\n\n        const distances = [0]\n        let totalDistance = 0\n        for (let i = 0; i < polyline.positions.length; i++) {\n          const positions = [polyline.positions[i], polyline.positions.length - 1 !== i\n            ? polyline.positions[i + 1]\n            : polyline.positions[0]]\n          const distance = getDistance(positions)\n          totalDistance += distance\n          distances.push(totalDistance)\n        }\n        polyline.distances = distances\n        polyline.distance = totalDistance\n      })\n    }\n  },\n  computed: {\n    primitivePolylines () {\n      const polylines = []\n      this.polylines.forEach((item, index) => {\n        const polyline = {\n          material: this.polylineMaterial,\n          positions: item.positions,\n          width: this.polylineWidth,\n          polylineIndex: index,\n          loop: true\n        }\n        polylines.push(polyline)\n      })\n      return polylines\n    },\n    labels () {\n      const labels = []\n      this.polylines.forEach((polyline, index) => {\n        const label = {\n          backgroundColor: this.backgroundColor,\n          fillColor: this.fillColor,\n          font: this.font,\n          horizontalOrigin: 1,\n          labelStyle: this.labelStyle,\n          outlineColor: this.outlineColor,\n          outlineWidth: this.outlineWidth,\n          pixelOffset: this.pixelOffset,\n          position: polyline.positions[polyline.positions.length - 1],\n          showBackground: this.showBackground,\n          disableDepthTestDistance: Cesium.SuperMapVersion ? 0 : Number.POSITIVE_INFINITY,\n          text: this.$vc.lang.measure.area +\n              ': ' +\n              (polyline.area > 1000000 ? (polyline.area / 1000000).toFixed(2) + 'km²' : polyline.area.toFixed(2) + '㎡')\n        }\n        labels.push(label)\n        polyline.positions.forEach((position, subIndex) => {\n          if (this.alongLine && polyline.positions.length > 1 && subIndex + 1 < polyline.distances.length) {\n            const label = {\n              backgroundColor: this.backgroundColor,\n              fillColor: this.fillColor,\n              font: this.font,\n              horizontalOrigin: 0,\n              labelStyle: this.labelStyle,\n              outlineColor: this.outlineColor,\n              outlineWidth: this.outlineWidth,\n              pixelOffset: this.pixelOffset,\n              position: subIndex !== polyline.positions.length - 1\n                ? this.getMidPoistion(polyline.positions[subIndex], polyline.positions[subIndex + 1])\n                : this.getMidPoistion(polyline.positions[subIndex], polyline.positions[0]),\n              showBackground: this.showBackground,\n              disableDepthTestDistance: Number.POSITIVE_INFINITY,\n              text: this.getDistanceText(polyline.distances[subIndex + 1] - polyline.distances[subIndex]),\n              verticalOrigin: 0\n            }\n            labels.push(label)\n          }\n        })\n      })\n      return labels\n    }\n  },\n  methods: {\n    getDistanceText (distance) {\n      return distance > 1000 ? (distance / 1000).toFixed(2) + 'km' : distance.toFixed(2) + 'm'\n    },\n    getMidPoistion (left, right) {\n      const { Cartesian3 } = Cesium\n      return Cartesian3.midpoint(left, right, new Cartesian3())\n    },\n    makeEllipsoidSurfaceAppearance (val) {\n      return new Cesium.EllipsoidSurfaceAppearance({\n        material: makeMaterial.call(this, val),\n        renderState: {\n          cull: {\n            enabled: false\n          }\n        }\n      })\n    },\n    makePolylineMaterialAppearance (val) {\n      return new Cesium.PolylineMaterialAppearance({\n        material: makeMaterial.call(this, val)\n      })\n    },\n    clone,\n    /**\n     * 用海伦公式获取传入坐标的构成的多边形的面积。\n     * @param {Array.Cartesian}\n     * @returns {Number} 返回面积数值。\n     */\n    getSurfaceArea (vals) {\n      const positions = clone(vals, true)\n      if (positions.length < 3) {\n        return 0\n      }\n      const {\n        Cartesian3,\n        EllipsoidTangentPlane,\n        Math: CesiumMath,\n        PolygonGeometryLibrary,\n        PolygonHierarchy,\n        VertexFormat,\n        ArcType\n      } = Cesium\n      const { viewer } = this\n      const perPositionHeight = !this.clampToGround\n      // Request the triangles that make up the polygon from Cesium.\n      // 获取组成多边形的三角形。\n      const tangentPlane = EllipsoidTangentPlane.fromPoints(positions, viewer.scene.globe.ellipsoid)\n      const polygons = PolygonGeometryLibrary.polygonsFromHierarchy(\n        new PolygonHierarchy(positions),\n        tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\n        this.clampToGround,\n        viewer.scene.globe.ellipsoid\n      )\n\n      const geom = PolygonGeometryLibrary.createGeometryFromPositions(\n        viewer.scene.globe.ellipsoid,\n        polygons.polygons[0],\n        CesiumMath.RADIANS_PER_DEGREE,\n        perPositionHeight,\n        VertexFormat.POSITION_ONLY,\n        ArcType.GEODESIC\n      )\n\n      if (geom.indices.length % 3 !== 0 || geom.attributes.position.values.length % 3 !== 0) {\n        // Something has gone wrong. We expect triangles. Can't calcuate area.\n        // 不是三角形，无法计算。\n        return 0\n      }\n      const coords = []\n      for (let i = 0; i < geom.attributes.position.values.length; i += 3) {\n        coords.push(\n          new Cartesian3(\n            geom.attributes.position.values[i],\n            geom.attributes.position.values[i + 1],\n            geom.attributes.position.values[i + 2]\n          )\n        )\n      }\n      let area = 0\n      for (let i = 0; i < geom.indices.length; i += 3) {\n        const ind1 = geom.indices[i]\n        const ind2 = geom.indices[i + 1]\n        const ind3 = geom.indices[i + 2]\n\n        const a = Cartesian3.distance(coords[ind1], coords[ind2])\n        const b = Cartesian3.distance(coords[ind2], coords[ind3])\n        const c = Cartesian3.distance(coords[ind3], coords[ind1])\n\n        // Heron's formula 海伦公式\n        const s = (a + b + c) / 2.0\n        area += Math.sqrt(s * (s - a) * (s - b) * (s - c))\n      }\n      return area\n    },\n    /**\n     * 用 @turf/area 获取传入坐标的构成的多边形的面积。实际上是投影面积。\n     * @param {Array.Cartesian}\n     * @returns {Number} 返回面积数值。\n     */\n    getProjectedArea (positions) {\n      const { Cartographic, Math: CesiumMath } = Cesium\n      const array = []\n      for (let i = 0, len = positions.length; i < len; i++) {\n        const cartographic = Cartographic.fromCartesian(positions[i], this.viewer.scene.globe.ellipsoid)\n        const longitude = CesiumMath.toDegrees(cartographic.longitude).toFixed(6)\n        const latitude = CesiumMath.toDegrees(cartographic.latitude).toFixed(6)\n        array.push({ x: longitude, y: latitude })\n      }\n      const arrs = []\n      const tems = []\n      arrs.push(tems)\n      for (let i = 0, len = array.length; i < len; i++) {\n        tems.push([array[i].x, array[i].y])\n      }\n      const polygons = {\n        type: 'FeatureCollection',\n        features: [\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: arrs\n            }\n          },\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: [[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]]\n            }\n          }\n        ]\n      }\n      return area(polygons)\n    },\n    clear () {\n      this.distance = 0\n      this.polylines = []\n      // this.labels = []\n      this.measuring = false\n    }\n  }\n}\n</script>\n","import VcMeasureArea from './VcMeasureArea.vue'\n\n// 按需引入该组件时自动引入下面组件才能正常工作\nimport * as PrimitiveCollection from '../../primitiveCollection'\nimport * as GroundPrimitive from '../../primitive/ground'\nimport * as GeometryInstance from '../../geometryInstance'\nimport * as PolygonGeometry from '../../geometryInstance/polygon'\nimport * as Primitive from '../../primitive'\nimport * as GroundPolylinePrimitive from '../../primitive/groundPolyline'\nimport * as GroundPolylineGeometry from '../../geometryInstance/groundPolyline'\nimport * as PolylineCollection from '../../primitiveCollection/polylineCollection'\nimport * as Polyline from '../../primitive/polyline'\nimport * as PointPrimitiveCollection from '../../primitiveCollection/pointCollection'\nimport * as PointPrimitive from '../../primitive/point'\nimport * as LabelCollection from '../../primitiveCollection/labelCollection'\nimport * as Label from '../../primitive/label'\n\nfunction plugin (Vue, options = {}) {\n  if (plugin.installed) {\n    return\n  }\n  plugin.installed = true\n\n  Vue.use(PrimitiveCollection)\n  Vue.use(GroundPrimitive)\n  Vue.use(GeometryInstance)\n  Vue.use(PolygonGeometry)\n  Vue.use(Primitive)\n  Vue.use(GroundPolylinePrimitive)\n  Vue.use(GroundPolylineGeometry)\n  Vue.use(PolylineCollection)\n  Vue.use(Polyline)\n  Vue.use(PointPrimitiveCollection)\n  Vue.use(PointPrimitive)\n  Vue.use(LabelCollection)\n  Vue.use(Label)\n\n  Vue.component(VcMeasureArea.name, VcMeasureArea)\n}\n\nexport default plugin\n\nexport {\n  VcMeasureArea,\n  plugin as install\n}\n"],"names":["name","mixins","mixinMeasure","data","index","type","measuring","polylines","props","removeLastPosition","Boolean","default","clampToGround","alongLine","polygonMaterial","Object","fabric","uniforms","color","watch","getSurfaceArea","getDistance","forEach","polyline","area","positions","distances","totalDistance","i","length","distance","push","computed","primitivePolylines","item","material","polylineMaterial","width","polylineWidth","polylineIndex","loop","labels","label","backgroundColor","fillColor","font","horizontalOrigin","labelStyle","outlineColor","outlineWidth","pixelOffset","position","showBackground","disableDepthTestDistance","Cesium","SuperMapVersion","Number","POSITIVE_INFINITY","text","$vc","lang","measure","toFixed","subIndex","getMidPoistion","getDistanceText","verticalOrigin","methods","left","right","Cartesian3","midpoint","makeEllipsoidSurfaceAppearance","val","EllipsoidSurfaceAppearance","makeMaterial","call","renderState","cull","enabled","makePolylineMaterialAppearance","PolylineMaterialAppearance","clone","vals","EllipsoidTangentPlane","CesiumMath","Math","PolygonGeometryLibrary","PolygonHierarchy","VertexFormat","ArcType","viewer","perPositionHeight","tangentPlane","fromPoints","scene","globe","ellipsoid","polygons","polygonsFromHierarchy","projectPointsOntoPlane","bind","geom","createGeometryFromPositions","RADIANS_PER_DEGREE","POSITION_ONLY","GEODESIC","indices","attributes","values","coords","ind1","ind2","ind3","a","b","c","s","sqrt","getProjectedArea","Cartographic","array","len","cartographic","fromCartesian","longitude","toDegrees","latitude","x","y","arrs","tems","features","properties","geometry","coordinates","clear","plugin","Vue","installed","use","PrimitiveCollection","GroundPrimitive","GeometryInstance","PolygonGeometry","Primitive","GroundPolylinePrimitive","GroundPolylineGeometry","PolylineCollection","Polyline","PointPrimitiveCollection","PointPrimitive","LabelCollection","Label","component","VcMeasureArea"],"mappings":"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"}